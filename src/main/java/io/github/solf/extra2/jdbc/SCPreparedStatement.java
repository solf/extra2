/**
 * Copyright Sergey Olefir
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.solf.extra2.jdbc;

import static io.github.solf.extra2.util.NullUtil.fakeVoid;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import javax.annotation.Nullable;

import org.eclipse.jdt.annotation.NonNullByDefault;

import io.github.solf.extra2.jdbc.SqlClient.SQLConsumer;
import io.github.solf.extra2.jdbc.SqlClient.SQLFunction;
import lombok.AllArgsConstructor;
import lombok.ToString;

/**
 * A version of SQL {@link PreparedStatement} that works with {@link SqlClient}
 * instance.
 *
 * @author Sergey Olefir
 */
@NonNullByDefault
@AllArgsConstructor
@ToString
public class SCPreparedStatement
{
	/**
	 * {@link SqlClient} this prepared statement is for.
	 */
	private final SqlClient sqlClient;
	
	/**
	 * SQL statement to be executed.
	 */
	private final String statementSql;
	
	/**
	 * If not null, prepared statement will be created with 'autoGeneratedKeys'
	 * parameter.
	 */
	@Nullable
	private final Integer autoGeneratedKeys;
	
	/**
	 * Code block for setting up prepared statement parameters.
	 */
	private final SQLConsumer<PreparedStatement> setupParameters;
	
    /**
     * Executes SQL statement
     * which must be an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or
     * <code>DELETE</code>; or an SQL statement that returns nothing,
     * such as a DDL statement.
     *
     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements
     *         or (2) 0 for SQL statements that return nothing
     */	
	public int executeUpdate()
		throws SQLException
	{
		return withStatement(ps -> sqlClient.executeUpdate(ps));
	}

    /**
     * Executes SQL statement
     * which must be an SQL Data Manipulation Language (DML) statement, such as <code>INSERT</code>, <code>UPDATE</code> or
     * <code>DELETE</code>; or an SQL statement that returns nothing,
     * such as a DDL statement.
     * <p>
     * The statement must have {@link Statement#RETURN_GENERATED_KEYS} specified
     * during its creation.
     *
     * @param keysRS handler for the resulting generated keys {@link ResultSet}
     * 		(should extract and process generated keys from the given {@link ResultSet}) 
     * 
     * @return either (1) the row count for SQL Data Manipulation Language (DML) statements
     *         or (2) 0 for SQL statements that return nothing
     */	
	public int executeUpdateProcessGeneratedKeys(SQLConsumer<ResultSet> keysRS)
		throws SQLException
	{
		return withStatement(ps -> sqlClient.executeUpdateProcessGeneratedKeys(ps, keysRS), true);
	}
	
	/**
	 * Runs given query and executes provided lambda for the ResultSet + returns a result:
	 * <p>
	 * int count = sqlClient.executeQuery("SELECT id FROM table WHERE id < 100", rs ->
	 * 	{
	 * 		int rows = 0;
	 *		while (rs.next())
	 *		{
	 *			rows++;
	 *		}
	 *		return rows;
	 *	}
	 * );
	 *
	 * @see #forEachRow(SQLConsumer)
	 */
	public <R> R executeQuery(SQLFunction<ResultSet, R> f)
		throws SQLException
	{
		return withStatement(ps -> sqlClient.executeQuery(ps, f));
	}

	/**
	 * Runs given query and executes provided lambda for the ResultSet e.g.:
	 * <p>
	 * sqlClient.executeQuery("SELECT id FROM table WHERE id < 100", rs ->
	 * 	{
	 *		while (rs.next())
	 *		{
	 *			results.add(rs.getInt(1));
	 *		}
	 *	}
	 * );
	 * 
	 * @see #forEachRow(SQLConsumer)
	 */
	public void executeQueryNoReturnValue(SQLConsumer<ResultSet> f)
		throws SQLException
	{
		withStatementNoValue(ps -> sqlClient.executeQueryNoReturnValue(ps, f));
	}

	/**
	 * Runs given query and executes provided lambda for each row in the result
	 * set, e.g.:
	 * <p>
	 * sqlClient.forEachRow("SELECT id FROM table WHERE id < 100", row -> { 
	 * 		results.add(row.getInt(1));
	 * });
	 * 
	 * @return number of rows processed
	 */
	public int forEachRow(SQLConsumer<ResultSet> f)
		throws SQLException
	{
		return withStatement(ps -> sqlClient.forEachRow(ps, f));
	}

	/**
	 * Runs given query and executes provided lambda for the only row that is
	 * supposed to be in result set; throws {@link SQLException} if result contains
	 * no rows or more than one row, e.g.:
	 * <p>
	 * sqlClient.forSingleRow("SELECT count(*) FROM table WHERE id < 100", row -> { 
	 * 		return row.getInt(1);
	 * });
	 * 
	 * @return resulting function value
	 */
	public <R> R forSingleRow(SQLFunction<ResultSet, R> f)
		throws SQLException
	{
		return withStatement(ps -> sqlClient.forSingleRow(ps, f));
	}

	/**
	 * Runs given query and executes provided lambda for the only row that is
	 * supposed to be in result set; throws {@link SQLException} if result contains
	 * no rows or more than one row, e.g.:
	 * <p>
	 * AtomicLong count = new AtomicLong();
	 * sqlClient.forSingleRow("SELECT count(*) FROM table WHERE id < 100", row -> { 
	 * 		count.set(row.getLong(1));
	 * });
	 * 
	 * @return resulting function value
	 */
	public void forSingleRowNoReturnValue(SQLConsumer<ResultSet> f)
		throws SQLException
	{
		withStatementNoValue(ps -> sqlClient.forSingleRowNoReturnValue(ps, f));
	}

	/**
	 * Runs given query and executes provided lambda for the only row that is
	 * supposed to be in result set; throws {@link SQLException} if result contains
	 * more than one row; returns null if result contains no rows, e.g.:
	 * <p>
	 * sqlClient.forZeroOrOneRow("SELECT count(*) FROM table WHERE id < 100", row -> { 
	 * 		return row.getInt(1);
	 * });
	 * 
	 * @return resulting function value or null if there are no result rows
	 */
	@Nullable
	public <R> R forZeroOrOneRow(SQLFunction<ResultSet, R> f)
		throws SQLException
	{
		return withStatement(ps -> sqlClient.forZeroOrOneRow(ps, f));
	}

	/**
	 * Runs given query and executes provided lambda for the only row that is
	 * supposed to be in result set; throws {@link SQLException} if result contains
	 * more than one row; does nothing if result contains no rows, e.g.:
	 * <p>
	 * sqlClient.forZeroOrOneRow("SELECT count(*) FROM table WHERE id < 100", row -> { 
	 * 		return row.getInt(1);
	 * });
	 * 
	 * @return true if there was one row, false if there were no rows
	 */
	public boolean forZeroOrOneRowNoReturnValue(SQLConsumer<ResultSet> f)
		throws SQLException
	{
		return withStatement(ps -> sqlClient.forZeroOrOneRowNoReturnValue(ps, f));
	}
	
	/**
	 * Creates {@link PreparedStatement} based on {@link #statementSql} and
	 * executes the provided handler with this statement. {@link PreparedStatement}
	 * is closed at the end.
	 */ 
	private <R> R withStatement(SQLFunction<PreparedStatement, R> ps)
		throws SQLException
	{
		return withStatement(ps, false);
	}
	
	/**
	 * Creates {@link PreparedStatement} based on {@link #statementSql} and
	 * executes the provided handler with this statement. {@link PreparedStatement}
	 * is closed at the end.
	 * 
	 * @param returnGeneratedKeys if true, then {@link PreparedStatement} is
	 * 		created with {@link Statement#RETURN_GENERATED_KEYS} flag (and
	 * 		it's expected that the handler will make use of the generated keys)
	 */
	private <R> R withStatement(SQLFunction<PreparedStatement, R> ps, final boolean returnGeneratedKeys)
		throws SQLException
	{
		@SuppressWarnings({"deprecation", "resource"}) PreparedStatement statement = 
			returnGeneratedKeys == false ?
				sqlClient.unsafePrepareStatement(statementSql)
			  : sqlClient.unsafePrepareStatement(statementSql, Statement.RETURN_GENERATED_KEYS);
				
		try
		{
			// Setup prepared statement parameters
			setupParameters.accept(statement);
			
			return ps.apply(statement);
		} finally
		{
			try
			{
				statement.close();
			} catch (SQLException e)
			{
				sqlClient.handlePreparedStatementCloseException(e);
			}
		}
	}
	
	/**
	 * Creates {@link PreparedStatement} based on {@link #statementSql} and
	 * executes the provided handler with this statement. {@link PreparedStatement}
	 * is closed at the end.
	 * <p>
	 * This is a version of the method that has no return value.
	 */ 
	private void withStatementNoValue(SQLConsumer<PreparedStatement> ps)
		throws SQLException
	{
		withStatement(rps -> {ps.accept(rps); return fakeVoid();});
	}
}
