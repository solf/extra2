/**
 * Copyright Sergey Olefir
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.solf.extra2.collection;

import static io.github.solf.extra2.testutil.AssertExtra.assertContains;
import static io.github.solf.extra2.testutil.AssertExtra.assertFails;
import static io.github.solf.extra2.util.NullUtil.fakeNonNull;
import static io.github.solf.extra2.util.NullUtil.nn;
import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertFalse;
import static org.testng.Assert.assertNotNull;
import static org.testng.Assert.assertNull;
import static org.testng.Assert.assertTrue;

import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Supplier;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import org.eclipse.jdt.annotation.NonNullByDefault;
import org.testng.annotations.Test;

import io.github.solf.extra2.exception.AssertionException;
import io.github.solf.extra2.io.BAOSInputStream;
import io.github.solf.extra2.util.TypeUtil;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import lombok.With;

/**
 * Tests for {@link RHashMap}
 *
 * @author Sergey Olefir
 */
@NonNullByDefault
public class ExtraRHashMapTest
{
	/**
	 * Interface for checking that two items are fully-equal (not just via equals).
	 */
	private static interface IFullyEquals
	{
		boolean fullyEquals(@Nullable Object obj);
	}
	
	/**
	 * Class for testing behavior of keys that can be equals() but not fully-equals.
	 */
	@AllArgsConstructor
	@EqualsAndHashCode(onlyExplicitlyIncluded = true)
	@ToString
	private static class TKeyWithValue implements Cloneable, Serializable, IFullyEquals
	{
		@EqualsAndHashCode.Include 
		private final String key;
		
		@With
		private int value;

		@Override
		@SuppressWarnings("all")
		public boolean fullyEquals(@Nullable Object obj) // generated by Eclipse
		{
			if( this == obj )
				return true;
			if( obj == null )
				return false;
			if( getClass() != obj.getClass() )
				return false;
			TKeyWithValue other = (TKeyWithValue)obj;
			if( key == null )
			{
				if( other.key != null )
					return false;
			}
			else if( !key.equals(other.key) )
				return false;
			if( value != other.value )
				return false;
			return true;
		}

		@Override
		public TKeyWithValue clone()
		{
			try
			{
				return (TKeyWithValue)super.clone();
			} catch( CloneNotSupportedException e )
			{
				throw new AssertionException();
			}
		}
	}

	/**
	 * Checks that two given keys are equals, including via {@link IFullyEquals}
	 * if appropriate.
	 */
	private static <K> void assertKeyEquals(K actual, K expected)
	{
		assertEquals(actual, expected, "Keys not equal: " + actual + " != " + expected);
		if ((actual != null) && (expected != null))
		{
			assertEquals(actual.hashCode(), expected.hashCode(), "Keys hashes not equal: " + actual + " != " + expected);
			if (actual instanceof IFullyEquals)
				assertTrue(((IFullyEquals)actual).fullyEquals(expected), "Keys not FULLY equal: " + actual + " != " + expected);
		}
	}

	private static final Object DEFAULT_OBJECT = new Object()
	{
		@Override
		public @Nonnull String toString()
		{
			return "DEFAULT_OBJECT/" + super.toString();
		}
	};
	
	
	/**
	 * Returns 'default' object
	 */
	@SuppressWarnings("unchecked")
	private static <T> T defaultObject()
	{
		return (T)DEFAULT_OBJECT;
	}
	

	/**
	 * Object instance that never equals anything.
	 */
	private static final Object NON_EQUAL_OBJECT = new Object()
	{
		@Override
		public @Nonnull String toString()
		{
			return "NON_EQUAL_OBJECT/" + super.toString();
		}
		
		@Override
		public int hashCode()
		{
			return super.hashCode();
		}

		@Override
		public boolean equals(@Nullable Object obj)
		{
			return false;
		}
	};
	
	/**
	 * Returns object that is NEVER equal to anything.
	 */
	@SuppressWarnings("unchecked")
	private static <T> T nonEqualObject()
	{
		return (T)NON_EQUAL_OBJECT;
	}
	
	/**
	 * Tests {@link RHashMap}
	 */
	@Test
	public void testRHashMap()
	{
		final TKeyWithValue key14_1 = new TKeyWithValue("14", 1);
		final TKeyWithValue key15_2 = new TKeyWithValue("55", 2);

		testRHashMapInternal(() -> new RHashMap<>(), null);
		testRHashMapInternal(() -> new RHashMap<>(5), null);
		testRHashMapInternal(() -> new RHashMap<>(7, 0.75f), null);
		
		Integer four = 4; 
		testRHashMapInternal(() -> new RHashMap<>(mapOf(key14_1, four, key15_2, 5)), mapOf(key14_1, four, key15_2, 5));
		
		testRHashMapInternal(() -> new RHashMap<TKeyWithValue, Integer>(mapOf(key14_1, four, key15_2, 5)).clone(), mapOf(key14_1, four, key15_2, 5));
	}
	
	/**
	 * Tests {@link RHashMap}
	 */
	@SuppressWarnings("deprecation")
	@NonNullByDefault({})
	private void testRHashMapInternal(@Nonnull Supplier<@Nonnull RHashMap<TKeyWithValue, Integer>> mapFactory, 
		@Nullable Map<TKeyWithValue, Integer> initialState)
	{
		final TKeyWithValue key1_1 = new TKeyWithValue("1", 1);
//		final TKeyWithValue key1_2 = new TKeyWithValue("1", 2);
		final TKeyWithValue key2_1 = new TKeyWithValue("2", 1);
		final TKeyWithValue key2_2 = new TKeyWithValue("2", 2);
		final TKeyWithValue key3_1 = new TKeyWithValue("3", 1);
		final TKeyWithValue key3_2 = new TKeyWithValue("3", 2);
		final TKeyWithValue key4_1 = new TKeyWithValue("4", 1);
//		final TKeyWithValue key4_2 = new TKeyWithValue("4", 2);
		
		{
			RHashMap<TKeyWithValue, Integer> map = mapFactory.get();
			compareRMapNonDestructively(map, initialState, mapOf());
		}

		{
			RHashMap<TKeyWithValue, Integer> map = mapFactory.get();
			assertNull(map.putRetainKey(key1_1, 1));
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1));
		}

		{
			@SuppressWarnings("null") RHashMap<TKeyWithValue, @Nullable Integer> map = mapFactory.get();
			assertNull(map.putRetainKey(key1_1, null));
			compareRMapNonDestructively(map, TypeUtil.coerceNullable(initialState), mapOf(key1_1, null));
		}

		{
			@SuppressWarnings("null") RHashMap<@Nullable TKeyWithValue, Integer> map = mapFactory.get();
			assertNull(map.putRetainKey(null, 1));
			compareRMapNonDestructively(map, TypeUtil.coerceNullable(initialState), mapOf(null, 1));
		}

		{
			@SuppressWarnings("null") RHashMap<@Nullable TKeyWithValue, @Nullable Integer> map = mapFactory.get();
			assertNull(map.putRetainKey(null, null));
			compareRMapNonDestructively(map, TypeUtil.coerceNullable(initialState), mapOf(null, null));
		}
		
		{
			RHashMap<TKeyWithValue, Integer> map = mapFactory.get();
			assertNull(map.putRetainKey(key1_1, 1));
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1));
			assertNull(map.putIfAbsent(key2_1, 2));
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2));
			assertEquals(map.putIfAbsent(key2_1, 5), (Integer)2);
			assertEquals(map.putIfAbsent(key2_2, 5), (Integer)2);
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2));
			assertNull(map.putRetainKey(key3_1, 3));
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2, key3_1, 3));
			assertEquals(map.putRetainKey(key3_2, 5), (Integer)3);
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2, key3_1, 5));
			assertEquals(map.putWithNewKey(key3_2, 5), (Integer)5);
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, 5));
			assertEquals(map.put(key3_1, 3), (Integer)5);
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, 3));
			compareRMapNonDestructively(map, initialState, map.toUnmodifiableJavaMap());
			
			assertEquals(map.putIfAbsent(key3_1, null), (Integer)3);
			assertEquals(map.putRetainKey(key3_1, null), (Integer)3);
			assertEquals(map.putIfAbsent(key3_1, 7), null);
			assertNull(map.putIfAbsent(null, 4));
			assertEquals(map.putIfAbsent(null, 5), (Integer)4);
			assertEquals(map.putIfAbsent(null, null), (Integer)4);
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
			compareRMapNonDestructively(map, initialState, map.toUnmodifiableJavaMap());
			
			assertEquals(map.getOrCreateValue(null, k -> 555), (Integer)4);
			assertEquals(map.getOrCreateValue(key1_1, k -> 555), (Integer)1);
			assertEquals(map.getOrCreateValue(key3_2, k -> 555), (Integer)null);
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
			assertEquals(map.getOrCreateValue(key4_1, k -> 444), (Integer)444);
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4, key4_1, 444));
			assertEquals(map.removeAndGet(null), (Integer)4);
			assertEquals(map.removeAndGet(key3_2), (Integer)null);
			assertEquals(map.removeAndGet(key4_1), (Integer)444);
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2));
			assertEquals(map.getOrCreateValue(null, k -> 4), (Integer)4);
			assertEquals(map.getOrCreateValue(key3_2, k -> null), (Integer)null);
			compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));

			compareRMapNonDestructively(map, initialState, map.toUnmodifiableJavaMap());
			
			{
				RHashMap<TKeyWithValue, Integer> rmap = new RHashMap<>(map);
				compareRMapNonDestructively(map, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				assertFalse(rmap.removeIfValue(key4_1, 1));
				assertFalse(rmap.remove(key4_1, 1));
				assertFalse(rmap.removeIfValue(key2_1, 3));
				assertFalse(rmap.remove(key2_1, null));
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				
				assertTrue(rmap.removeIfValue(key3_2, null));
				assertTrue(rmap.removeIfValue(null, 4));
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2));
				
				assertTrue(rmap.removeIfValue(key1_1, 1));
				assertTrue(rmap.remove(key2_1, 2));
				compareRMapNonDestructively(rmap, initialState, mapOf());
			}
			
			{
				RHashMap<TKeyWithValue, Integer> rmap = new RHashMap<>(map);
				
				assertNull(rmap.replace(key4_1, 45));
				assertEquals(rmap.replace(key2_2, 22), (Integer)2);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 22, key3_2, null, null, 4));
				
				assertEquals(rmap.replace(null, 44), (Integer)4);
				assertEquals(rmap.replace(key3_1, 33), null);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 22, key3_2, 33, null, 44));
				
				assertEquals(rmap.removeAndGet(null), (Integer)44);
				assertNull(rmap.replace(null, 44));
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 22, key3_2, 33));
			}
			
			{
				RHashMap<TKeyWithValue, Integer> rmap = new RHashMap<>(map);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				
				assertFalse(rmap.replace(key4_1, 45, 45));
				assertTrue(rmap.replace(key2_2, 2, 22));
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 22, key3_2, null, null, 4));
				
				assertFalse(rmap.replace(null, 5, 7));
				assertFalse(rmap.replace(key3_2, 8, 9));
				assertFalse(rmap.replace(key1_1, null, 11));
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 22, key3_2, null, null, 4));
				
				assertTrue(rmap.replace(null, 4, 44));
				assertTrue(rmap.replace(key3_2, null, 33));
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 22, key3_2, 33, null, 44));
				
				assertEquals(rmap.removeAndGet(null), (Integer)44);
				assertFalse(rmap.replace(null, 44, 55));
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 22, key3_2, 33));
			}
			
			{
				RHashMap<TKeyWithValue, Integer> rmap = new RHashMap<>(map);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				
				assertEquals(rmap.computeIfAbsent(key1_1, k -> 34), (Integer)1);
				assertNull(rmap.computeIfAbsent(key4_1, k -> null));
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				
				assertEquals(rmap.computeIfAbsent(key4_1, k -> k.equals(key4_1) ? 44 : 88), (Integer)44);
				assertEquals(rmap.computeIfAbsent(null, k -> 55), (Integer)4);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4, key4_1, 44));
				
				assertEquals(rmap.removeAndGet(null), (Integer)4);
				assertNull(rmap.computeIfAbsent(null, k -> null));
				assertFalse(rmap.hasKey(null));
				assertEquals(rmap.computeIfAbsent(null, k -> 77), (Integer)77);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 77, key4_1, 44));
				
				rmap.clear();
				assertNull(rmap.computeIfAbsent(null, k -> null));
				assertFalse(rmap.hasKey(null));
				assertEquals(rmap.size(), 0);
				assertEquals(rmap.computeIfAbsent(null, k -> 55), (Integer)55);
				compareRMapNonDestructively(rmap, null, mapOf(null, 55));
			}
			
			{
				RHashMap<TKeyWithValue, Integer> rmap = new RHashMap<>(map);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				
				assertNull(rmap.computeIfPresent(key4_1, (k,v) -> 123));
				assertNull(rmap.computeIfPresent(key3_2, (k,v) -> 123));
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				
				assertEquals(rmap.computeIfPresent(key2_1, (k,v) -> v * 11), (Integer)22);
				assertEquals(rmap.computeIfPresent(null, (k,v) -> 777), (Integer)777);
				assertEquals(rmap.computeIfPresent(key3_2, (k,v) -> null), null); // does nothing!
				assertEquals(rmap.computeIfPresent(key1_1, (k,v) -> k.equals(key1_1) ? null : 765), null); // removes
				compareRMapNonDestructively(rmap, initialState, mapOf(key2_1, 22, null, 777, key3_2, null));
				
				assertEquals(rmap.removeAndGet(null), (Integer)777);
				assertEquals(rmap.computeIfPresent(null, (k,v) -> 777), null);
				compareRMapNonDestructively(rmap, initialState, mapOf(key2_1, 22, key3_2, null));
				
				rmap.clear();
				assertNull(rmap.computeIfPresent(null, (k,v) -> 123));
				assertFalse(rmap.hasKey(null));
				assertEquals(rmap.size(), 0);
				compareRMapNonDestructively(rmap, null, mapOf());
			}
			
			
			{
				RHashMap<TKeyWithValue, Integer> rmap = new RHashMap<>(map);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				
				assertEquals(rmap.compute(key4_1, (k,v) -> k.equals(key4_1) ? (v == null ? 44 : 55) : null), (Integer)44);
				assertEquals(rmap.compute(key3_2, (k,v) -> k.equals(key3_2) ? (v == null ? 33 : 55) : null), (Integer)33);
				assertEquals(rmap.compute(null, (k,v) -> k == null ? nn(v) * 22 : 3333), (Integer)88);
				assertEquals(rmap.compute(key2_1, (k,v) -> null), null);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key3_2, 33, null, 88, key4_1, 44));
				
				rmap.clear();
				assertEquals(rmap.compute(null, (k,v) -> 123), (Integer)123);
				assertTrue(rmap.hasKey(null));
				assertEquals(rmap.size(), 1);
				compareRMapNonDestructively(rmap, null, mapOf(null, 123));
			}

			
			{
				RHashMap<TKeyWithValue, Integer> rmap = new RHashMap<>(map);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				
				assertEquals(rmap.merge(key4_1, fakeNonNull(), (v1, v2) -> 123), null);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4, key4_1, null));
				
				assertEquals(rmap.merge(key2_1, 55, (v1, v2) -> v1 == 2 ? null : v2), null);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key3_2, null, null, 4, key4_1, null));
				
				assertEquals(rmap.merge(null, 55, (v1, v2) -> v1 * v2), (Integer)220);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key3_2, null, null, 220, key4_1, null));
				
				assertEquals(rmap.merge(key4_1, 1024, (v1, v2) -> {throw new AssertionException();}), (Integer)1024);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key3_2, null, null, 220, key4_1, 1024));
				
				rmap.clear();
				assertEquals(rmap.merge(null, 7, (v1, v2) -> 123), (Integer)7);
				assertTrue(rmap.hasKey(null));
				assertEquals(rmap.size(), 1);
				assertEquals(rmap.merge(null, 7, (v1, v2) -> v1 * v2), (Integer)49);
				compareRMapNonDestructively(rmap, null, mapOf(null, 49));
			}
			
			{
				// Check clone decouple
				RHashMap<TKeyWithValue, Integer> rmap = new RHashMap<>(map);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				
				RHashMap<TKeyWithValue, Integer> rmap2 = rmap.clone();
				compareRMapNonDestructively(rmap2, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				
				rmap2.putWithNewKey(key4_1, 444);
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				compareRMapNonDestructively(rmap2, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4, key4_1, 444));
				
				rmap2.clear();
				compareRMapNonDestructively(rmap, initialState, mapOf(key1_1, 1, key2_1, 2, key3_2, null, null, 4));
				compareRMapNonDestructively(rmap2, null, mapOf());
			}
		}
	}
	
	/**
	 * Checks that the given {@link RHashMap} is fully the same as initial state +
	 * expected changes map (this check is non-destructive).
	 */
	@NonNullByDefault({})
	private static <K, V> void compareRMapNonDestructively(@Nonnull RHashMap<K, V> srcMap, 
		@Nullable Map<K, V> initialState, @Nonnull Map<K, V> srcExpectedChanges)
	{
		Map<K, V> mergedMap;
		if (initialState != null)
		{
			mergedMap = new HashMap<>(initialState);
			mergedMap.putAll(srcExpectedChanges);
		}
		else
			mergedMap = srcExpectedChanges;
		
		compareRMapNonDestructively(srcMap, mergedMap);
	}
	
	/**
	 * Checks that the given {@link RHashMap} is fully the same as expected map
	 * (this check is non-destructive).
	 */
	@SuppressWarnings({"deprecation", "unlikely-arg-type"})
	private static <K, V> void compareRMapNonDestructively(RHashMap<K, V> srcMap, Map<K, V> srcExpected)
	{
		final boolean expectedNullKey;
		final boolean expectedNullValue;
		{
			Map<K, V> expected = srcExpected;
			assertEquals(srcMap.size(), expected.size());
			assertEquals(srcMap.isEmpty(), expected.size() == 0);
			
			expectedNullKey = expected.containsKey(null);
			expectedNullValue = expected.containsValue(null);
		}
		
		{
			// Non-destructive tests of argument map.
			RHashMap<K, V> actual = srcMap;
			
			{
				Map<K, V> expected = srcExpected;
				
				for (V v : expected.values())
				{
					assertContains(actual.toString(), "" + v);
					assertContains(actual.entrySet().toString(), "" + v);
				}
				
				assertEquals(actual.hasKey(fakeNonNull()), expectedNullKey);
				assertEquals(actual.containsKey(null), expectedNullKey);
				assertEquals(actual.containsValue(null), expectedNullValue);
				
				Set<K> keySet = actual.keySet();
				Collection<V> values = actual.values();
				Set<Entry<K, V>> entrySet = actual.entrySet();
				assertEquals(keySet.size(), expected.size());
				assertEquals(values.size(), expected.size());
				assertEquals(entrySet.size(), expected.size());
				
				for (Entry<K, V> entry : expected.entrySet())
				{
					K key = entry.getKey();
					V value = entry.getValue();
					
					assertTrue(actual.hasKey(key));
					assertTrue(actual.containsKey(key));
					assertTrue(keySet.contains(key));
					assertFalse(actual.hasKey(nonEqualObject()));
					assertFalse(actual.containsKey(nonEqualObject()));
					assertFalse(keySet.contains(nonEqualObject()));
					
					assertTrue(actual.containsValue(value), "" + value + " : " + actual);
					assertTrue(values.contains(value));
					assertFalse(actual.containsValue(nonEqualObject()));
					assertFalse(values.contains(nonEqualObject()));
					
					assertTrue(entrySet.contains(entry));
					assertFalse(entrySet.contains(nonEqualObject()));
					
					assertNull(actual.get(nonEqualObject()));
					assertNull(actual.getValue(nonEqualObject()));
					assertNull(actual.getKey(nonEqualObject()));
					assertNull(actual.getEntry(nonEqualObject()));
					assertNull(actual.getLiveEntry(nonEqualObject()));
					
					assertEquals(actual.get(key), value);
					assertEquals(actual.getValue(key), value);
					assertKeyEquals(actual.getKey(key), key);
					
					assertKeyEquals(nn(actual.getEntry(key)).getKey(), key);
					assertEquals(nn(actual.getEntry(key)).getValue(), value);
					assertKeyEquals(nn(actual.getLiveEntry(key)).getKey(), key);
					assertEquals(nn(actual.getLiveEntry(key)).getValue(), value);
					
					assertEquals(actual.getOrDefault(key, defaultObject()), value);
					assertEquals(actual.getOrFallback(key, defaultObject()), value);

					assertEquals(actual.getOrDefault(nonEqualObject(), defaultObject()), defaultObject());
					assertEquals(actual.getOrFallback(nonEqualObject(), defaultObject()), defaultObject());
					
					assertNull(actual.getOrDefault(nonEqualObject(), fakeNonNull()));
					assertNull(actual.getOrFallback(nonEqualObject(), fakeNonNull()));
				}
			}
			
			{
				// Check via read-only entry iterables.
				for (ForIterable<@Nonnull ReadOnlyEntry<K, V>> fIter : Arrays.asList(actual, actual.entries(), ForIterable.of(actual.entries())))
				{
					HashMap<K, V> expected = new HashMap<>(srcExpected);
					for (ReadOnlyEntry<K, V> entry : fIter)
					{
						K key = entry.getKey();
						V value = entry.getValue();
						
						Entry<K, V> expectedEntry = removeEntry(expected, key);
						
						assertKeyEquals(key, expectedEntry.getKey());
						assertEquals(value, expectedEntry.getValue());
					}
					assertEquals(expected.size(), 0);
				}
			}
			
			{
				// Check via iterators w/ removal
				for (int i = 0; i < 2; i++)
				{
					RHashMap<K, V> map = actual.clone();
					Iterator<ReadOnlyEntry<K, V>> fIter = i == 0 ? map.iterator() : map.entries().iterator();
					
					HashMap<K, V> expected = new HashMap<>(srcExpected);
					while (fIter.hasNext())
					{
						ReadOnlyEntry<K, V> entry = fIter.next();
						fIter.remove();
						
						K key = entry.getKey();
						V value = entry.getValue();
						
						Entry<K, V> expectedEntry = removeEntry(expected, key);
						
						assertKeyEquals(key, expectedEntry.getKey());
						assertEquals(value, expectedEntry.getValue());
					}
					assertEquals(expected.size(), 0);
					assertEquals(map.size(), 0);
				}
			}
			
			{
				// Hack a test for ForIterable.of(..) here as well
				RHashMap<K, V> map = actual.clone();
				ForIterable<Entry<K, V>> fi = ForIterable.of(map.entrySet());
				{
					Iterator<Entry<K, V>> iter = fi.iterator();
					if (iter.hasNext())
					{
						iter.next();
						assertFails(() -> iter.remove(), "UnsupportedOperationException");
					}
				}
				
				ForIterable<Entry<K, V>> fIter = ForIterable.of(map.entrySet());
				HashMap<K, V> expected = new HashMap<>(srcExpected);
				for (Entry<K, V> entry : fIter)
				{
					K key = entry.getKey();
					V value = entry.getValue();
					
					Entry<K, V> expectedEntry = removeEntry(expected, key);
					
					assertKeyEquals(key, expectedEntry.getKey());
					assertEquals(value, expectedEntry.getValue());
				}
				assertEquals(expected.size(), 0);
			}
			
			{
				// Check via key iterable.
				HashMap<K, V> expected = new HashMap<>(srcExpected);
				for (K key : actual.keys())
				{
					Entry<K, V> expectedEntry = removeEntry(expected, key);
					assertKeyEquals(key, expectedEntry.getKey());
				}
				assertEquals(expected.size(), 0);
			}
			
			{
				// Check via values iterable.
				HashMap<K, V> expected = new HashMap<>(srcExpected);
				for (V value : actual.vals())
					removeFirstEntryByValue(expected, value);
				assertEquals(expected.size(), 0);
			}
			
		}
	
		// Below are destructive tests of various copies of argument map
		
		{
			// Check via live entries
			for (Function<RHashMap<K, V>, Iterator<Entry<K, V>>> factory : buildMapAccessors(
				(RHashMap<K, V> m) -> m.liveEntries(), 
				(RHashMap<K, V> m) -> m.entrySet().iterator()))
			{
				RHashMap<K, V> actual = new RHashMap<>(srcMap);
				HashMap<K, V> expected = new HashMap<>(srcExpected);
				
				Iterator<Entry<K, V>> iter = factory.apply(actual);
				while (iter.hasNext())
				{
					Entry<K, V> next = iter.next();
					K key = next.getKey();
					Entry<K, V> eEntry = removeEntry(expected, key);
					assertKeyEquals(key, eEntry.getKey());
					assertEquals(next.getValue(), eEntry.getValue());
				}
				assertEquals(expected.size(), 0);
				
				// Now with remove
				expected = new HashMap<>(srcExpected);
				iter = factory.apply(actual);
				while (iter.hasNext())
				{
					Entry<K, V> next = iter.next();
					iter.remove();
					K key = next.getKey();
					Entry<K, V> eEntry = removeEntry(expected, key);
					assertKeyEquals(key, eEntry.getKey());
					assertEquals(next.getValue(), eEntry.getValue());
				}
				assertEquals(expected.size(), 0, "actual: " + actual + ", expected: " + expected);
				assertEquals(actual.size(), 0);
			}
		}
		
		{
			// Check via live keys
			for (Function<RHashMap<K, V>, Iterator<K>> factory : buildMapAccessors(
				(RHashMap<K, V> m) -> m.liveKeys(), 
				(RHashMap<K, V> m) -> m.keySet().iterator()
			))
			{
				RHashMap<K, V> actual = srcMap.clone();
				HashMap<K, V> expected = new HashMap<>(srcExpected);
				
				Iterator<K> iter = factory.apply(actual);
				while (iter.hasNext())
				{
					K key = iter.next();
					Entry<K, V> eEntry = removeEntry(expected, key);
					assertKeyEquals(key, eEntry.getKey());
				}
				assertEquals(expected.size(), 0);
				
				// Now with remove
				expected = new HashMap<>(srcExpected);
				iter = factory.apply(actual);
				while (iter.hasNext())
				{
					K key = iter.next();
					iter.remove();
					Entry<K, V> eEntry = removeEntry(expected, key);
					assertKeyEquals(key, eEntry.getKey());
				}
				assertEquals(expected.size(), 0);
				assertEquals(actual.size(), 0);
			}
		}
		
		{
			// Check via live values
			for (Function<RHashMap<K, V>, Iterator<V>> factory : buildMapAccessors(
				(RHashMap<K, V> m) -> m.liveVals(), 
				(RHashMap<K, V> m) -> m.values().iterator()
			))
			{
				RHashMap<K, V> actual = cloneViaSerialization(srcMap);
				HashMap<K, V> expected = new HashMap<>(srcExpected);
				
				Iterator<V> iter = factory.apply(actual);
				while (iter.hasNext())
					removeFirstEntryByValue(expected, iter.next());
				assertEquals(expected.size(), 0);
				
				// Now with remove
				expected = new HashMap<>(srcExpected);
				iter = factory.apply(actual);
				while (iter.hasNext())
				{
					removeFirstEntryByValue(expected, iter.next());
					iter.remove();
				}
				assertEquals(expected.size(), 0);
				assertEquals(actual.size(), 0);
			}
		}
		
		{
			// Check via EntrySet
			RHashMap<K, V> actual = new RHashMap<>(srcMap);
			HashMap<K, V> expected = new HashMap<>(srcExpected);
			
			Set<Entry<K, V>> aSet = actual.entrySet();
			assertEquals(aSet.size(), expected.size());
			
			for (Entry<K, V> entry : expected.entrySet())
				assertTrue(aSet.contains(entry));

			actual = srcMap.clone();
			
			for (Entry<K, V> entry : expected.entrySet())
			{
				assertFalse(actual.entrySet().contains(
					new RHashMap.Entry<K, V>(entry.getKey(), nonEqualObject())));
				assertFalse(actual.entrySet().contains(
					new RHashMap.Entry<K, V>(nonEqualObject(), entry.getValue())));
				assertFalse(actual.entrySet().contains(
					new RHashMap.Entry<K, V>(nonEqualObject(), nonEqualObject())));
			}
			
			{
				final RHashMap<K, V> map = actual;
				assertFails(() -> map.entrySet().remove(nonEqualObject()), "UnsupportedOperationException");
			}
			
			assertEquals(actual.size(), expected.size());
			actual.entrySet().clear();
			assertEquals(actual.size(), 0);
		}
		
		{
			// Check via KeySet
			RHashMap<K, V> actual = srcMap.clone();
			HashMap<K, V> expected = new HashMap<>(srcExpected);
			
			Set<K> aSet = actual.keySet();
			assertEquals(aSet.size(), expected.size());
			
			for (K key : expected.keySet())
				assertTrue(aSet.contains(key));
			
			for (K key : expected.keySet())
				assertTrue(aSet.remove(key));
			
			assertEquals(actual.size(), 0);

			actual = srcMap.clone();
			
			assertFalse(actual.keySet().remove(nonEqualObject()));
			
			assertEquals(actual.size(), expected.size());
			actual.keySet().clear();
			assertEquals(actual.size(), 0);
		}
		
		{
			// Check via values()
			RHashMap<K, V> actual = cloneViaSerialization(srcMap);
			HashMap<K, V> expected = new HashMap<>(srcExpected);
			
			Collection<V> values = actual.values();
			assertEquals(values.size(), expected.size());
			
			for (V value : expected.values())
				assertTrue(values.contains(value));
			
			actual = srcMap.clone();
			
			assertEquals(actual.size(), expected.size());
			actual.values().clear();
			assertEquals(actual.size(), 0);
		}
		
		{
			// Check remove
			RHashMap<K, V> actual = cloneViaSerialization(srcMap);
			HashMap<K, V> expected = new HashMap<>(srcExpected);
			
			assertNull(actual.remove(nonEqualObject()));
			
			for (Entry<K, V> entry : expected.entrySet())
				assertEquals(actual.remove(entry.getKey()), entry.getValue());
		}
		
		{
			// Check removeAndGet
			RHashMap<K, V> actual = srcMap.clone();
			HashMap<K, V> expected = new HashMap<>(srcExpected);

			assertNull(actual.removeAndGet(nonEqualObject()));
			
			for (Entry<K, V> entry : expected.entrySet())
				assertEquals(actual.removeAndGet(entry.getKey()), entry.getValue());
		}
		
		{
			// Check clear
			RHashMap<K, V> actual = new RHashMap<>(srcMap);

			actual.clear();
			
			assertEquals(actual.size(), 0);
		}
	}
	
	/**
	 * Removes & returns matching entry from the given map.
	 */
	private static <K,V> Map.Entry<K, V> removeEntry(Map<K, V> map, K key)
	{
		Map.Entry<K, V> result = null;
		Iterator<Entry<K, V>> iter = map.entrySet().iterator();
		while (iter.hasNext())
		{
			Entry<K, V> next = iter.next();
			K nextKey = next.getKey();
			if (Objects.equals(key, nextKey))
			{
				assertKeyEquals(nextKey, key);
				assertNull(result, "" + result);
				result = next;
				iter.remove();
			}
		}
		
		assertNotNull(result, "no " + key + " in: " + map);
		assert result != null; // for compiler
		
		return result;
	}
	
	/**
	 * Builds an iterable of map accessors.
	 */
	@SafeVarargs
	private static <T, K, V> Iterable<Function<RHashMap<K, V>, T>> buildMapAccessors(
		Function<RHashMap<K, V>, T>... funcs)
	{
		return Arrays.asList(funcs);
	}
	
	/**
	 * Removes & returns matching entry from the given map.
	 */
	private static <K,V> Map.Entry<K, V> removeFirstEntryByValue(Map<K, V> map, V value)
	{
		Iterator<Entry<K, V>> iter = map.entrySet().iterator();
		while (iter.hasNext())
		{
			Entry<K, V> next = iter.next();
			if (Objects.equals(value, next.getValue()))
			{
				iter.remove();
				return next;
			}
		}
		
		throw new IllegalStateException("no value " + value + " in: " + map);
	}
	
	private static <O extends Serializable> O cloneViaSerialization(O src)
	{
		try
		{
			try (
				ByteArrayOutputStream os = new ByteArrayOutputStream(2048);
				
				ObjectOutputStream oos = new ObjectOutputStream(os);
			) {
			
				oos.writeObject(src);
				oos.flush();
				
				try (
					BAOSInputStream is = new BAOSInputStream(os);
					ObjectInputStream ois = new ObjectInputStream(is);
				) {
					@SuppressWarnings("unchecked") O result = (O)ois.readObject();
					
					return result;
				}
			}
		} catch (Exception e)
		{
			throw new RuntimeException(e);
		}
	}
	
	@SuppressWarnings("unchecked")
	private static <K, V> Map<K, V> mapOf(@Nullable Object... keyValues)
	{
		HashMap<K, V> result = new HashMap<>();
		
		for (int i = 0; i < keyValues.length; i+=2)
			result.put((K)keyValues[i], (V)keyValues[i + 1]);
		
		return Collections.unmodifiableMap(result);
	}
}
